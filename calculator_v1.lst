                 -1   $MODDE0CV
0000              1   ;  MODDDE2: Register definition for DE2-8052 softcore
0000              2   ;
0000              3   ;   Copyright (C) 2011  Jesus Calvino-Fraga, jesusc at ece.ubc.ca
0000              4   ;
0000              5   ;   This library is free software; you can redistribute it and/or
0000              6   ;   modify it under the terms of the GNU Lesser General Public
0000              7   ;   License as published by the Free Software Foundation; either
0000              8   ;   version 2.1 of the License, or (at your option) any later version.
0000              9   ;
0000             10   ;   This library is distributed in the hope that it will be useful,
0000             11   ;   but WITHOUT ANY WARRANTY; without even the implied warranty of
0000             12   ;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
0000             13   ;   Lesser General Public License for more details.
0000             14   ;
0000             15   ;   You should have received a copy of the GNU Lesser General Public
0000             16   ;   License along with this library; if not, write to the Free Software
0000             17   ;   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
0000             18   ;
0000             19       
0000             20   P0     DATA  080H  ;PORT 0
0000             21   SP     DATA  081H  ;STACK POINTER
0000             22   DPL    DATA  082H  ;DATA POINTER 0 - LOW BYTE
0000             23   DPH    DATA  083H  ;DATA POINTER 0 - HIGH BYTE
0000             24   DPL1   DATA  084H  ;DATA POINTER 1 - LOW BYTE
0000             25   DPH1   DATA  085H  ;DATA POINTER 1 - HIGH BYTE
0000             26   DPS    DATA  086H  ;DATA POINTER SELECT. DPH1, DPL1 active when DPS.0=1
0000             27   PCON   DATA  087H  ;POWER CONTROL
0000             28   TCON   DATA  088H  ;TIMER CONTROL
0000             29   TMOD   DATA  089H  ;TIMER MODE
0000             30   TL0    DATA  08AH  ;TIMER 0 - LOW BYTE
0000             31   TL1    DATA  08BH  ;TIMER 1 - LOW BYTE
0000             32   TH0    DATA  08CH  ;TIMER 0 - HIGH BYTE
0000             33   TH1    DATA  08DH  ;TIMER 1 - HIGH BYTE
0000             34   P1     DATA  090H  ;PORT 1
0000             35   SCON   DATA  098H  ;SERIAL PORT CONTROL
0000             36   SBUF   DATA  099H  ;SERIAL PORT BUFFER
0000             37   P2     DATA  0A0H  ;PORT 2
0000             38   IE     DATA  0A8H  ;INTERRUPT ENABLE
0000             39   P3     DATA  0B0H  ;PORT 3
0000             40   IP     DATA  0B8H  ;INTERRUPT PRIORITY
0000             41   T2CON  DATA  0C8H  ;TIMER 2 CONTROL
0000             42   T2MOD  DATA  0C9H  ;TIMER 2 MODE
0000             43   RCAP2L DATA  0CAH  ;TIMER 2 CAPTURE REGISTER - LOW BYTE
0000             44   RCAP2H DATA  0CBH  ;TIMER 2 CAPTURE REGISTER - HIGH BYTE
0000             45   TL2    DATA  0CCH  ;TIMER 2 - LOW BYTE
0000             46   TH2    DATA  0CDH  ;TIMER 2 - HIGH BYTE
0000             47   PSW    DATA  0D0H  ;PROGRAM STATUS WORD
0000             48   ACC    DATA  0E0H  ;ACCUMULATOR
0000             49   B      DATA  0F0H  ;MULTIPLICATION REGISTER
0000             50   IT0    BIT   088H  ;TCON.0 - EXT. INTERRUPT 0 TYPE
0000             51   IE0    BIT   089H  ;TCON.1 - EXT. INTERRUPT 0 EDGE FLAG
0000             52   IT1    BIT   08AH  ;TCON.2 - EXT. INTERRUPT 1 TYPE
0000             53   IE1    BIT   08BH  ;TCON.3 - EXT. INTERRUPT 1 EDGE FLAG
0000             54   TR0    BIT   08CH  ;TCON.4 - TIMER 0 ON/OFF CONTROL
0000             55   TF0    BIT   08DH  ;TCON.5 - TIMER 0 OVERFLOW FLAG
0000             56   TR1    BIT   08EH  ;TCON.6 - TIMER 1 ON/OFF CONTROL
0000             57   TF1    BIT   08FH  ;TCON.7 - TIMER 1 OVERFLOW FLAG
0000             58   RI     BIT   098H  ;SCON.0 - RECEIVE INTERRUPT FLAG
0000             59   TI     BIT   099H  ;SCON.1 - TRANSMIT INTERRUPT FLAG
0000             60   RB8    BIT   09AH  ;SCON.2 - RECEIVE BIT 8
0000             61   TB8    BIT   09BH  ;SCON.3 - TRANSMIT BIT 8
0000             62   REN    BIT   09CH  ;SCON.4 - RECEIVE ENABLE
0000             63   SM2    BIT   09DH  ;SCON.5 - SERIAL MODE CONTROL BIT 2
0000             64   SM1    BIT   09EH  ;SCON.6 - SERIAL MODE CONTROL BIT 1
0000             65   SM0    BIT   09FH  ;SCON.7 - SERIAL MODE CONTROL BIT 0
0000             66   EX0    BIT   0A8H  ;IE.0 - EXTERNAL INTERRUPT 0 ENABLE
0000             67   ET0    BIT   0A9H  ;IE.1 - TIMER 0 INTERRUPT ENABLE
0000             68   EX1    BIT   0AAH  ;IE.2 - EXTERNAL INTERRUPT 1 ENABLE
0000             69   ET1    BIT   0ABH  ;IE.3 - TIMER 1 INTERRUPT ENABLE
0000             70   ES     BIT   0ACH  ;IE.4 - SERIAL PORT INTERRUPT ENABLE
0000             71   ET2    BIT   0ADH  ;IE.5 - TIMER 2 INTERRUPT ENABLE
0000             72   EA     BIT   0AFH  ;IE.7 - GLOBAL INTERRUPT ENABLE
0000             73   RXD    BIT   0B0H  ;P3.0 - SERIAL PORT RECEIVE INPUT
0000             74   TXD    BIT   0B1H  ;P3.1 - SERIAL PORT TRANSMIT OUTPUT
0000             75   INT0   BIT   0B2H  ;P3.2 - EXTERNAL INTERRUPT 0 INPUT
0000             76   INT1   BIT   0B3H  ;P3.3 - EXTERNAL INTERRUPT 1 INPUT
0000             77   T0     BIT   0B4H  ;P3.4 - TIMER 0 COUNT INPUT
0000             78   T1     BIT   0B5H  ;P3.5 - TIMER 1 COUNT INPUT
0000             79   WR     BIT   0B6H  ;P3.6 - WRITE CONTROL FOR EXT. MEMORY
0000             80   RD     BIT   0B7H  ;P3.7 - READ CONTROL FOR EXT. MEMORY
0000             81   PX0    BIT   0B8H  ;IP.0 - EXTERNAL INTERRUPT 0 PRIORITY
0000             82   PT0    BIT   0B9H  ;IP.1 - TIMER 0 PRIORITY
0000             83   PX1    BIT   0BAH  ;IP.2 - EXTERNAL INTERRUPT 1 PRIORITY
0000             84   PT1    BIT   0BBH  ;IP.3 - TIMER 1 PRIORITY
0000             85   PS     BIT   0BCH  ;IP.4 - SERIAL PORT PRIORITY
0000             86   PT2    BIT   0BDH  ;IP.5 - TIMER 2 PRIORITY
0000             87   CAP2   BIT   0C8H  ;T2CON.0 - CAPTURE OR RELOAD SELECT
0000             88   CNT2   BIT   0C9H  ;T2CON.1 - TIMER OR COUNTER SELECT
0000             89   TR2    BIT   0CAH  ;T2CON.2 - TIMER 2 ON/OFF CONTROL
0000             90   EXEN2  BIT   0CBH  ;T2CON.3 - TIMER 2 EXTERNAL ENABLE FLAG
0000             91   TCLK   BIT   0CCH  ;T2CON.4 - TRANSMIT CLOCK SELECT
0000             92   RCLK   BIT   0CDH  ;T2CON.5 - RECEIVE CLOCK SELECTT
0000             93   EXF2   BIT   0CEH  ;T2CON.6 - EXTERNAL TRANSITION FLAG
0000             94   TF2    BIT   0CFH  ;T2CON.7 - TIMER 2 OVERFLOW FLAG
0000             95   P      BIT   0D0H  ;PSW.0 - ACCUMULATOR PARITY FLAG
0000             96   OV     BIT   0D2H  ;PSW.2 - OVERFLOW FLAG
0000             97   RS0    BIT   0D3H  ;PSW.3 - REGISTER BANK SELECT 0
0000             98   RS1    BIT   0D4H  ;PSW.4 - REGISTER BANK SELECT 1
0000             99   F0     BIT   0D5H  ;PSW.5 - FLAG 0
0000            100   AC     BIT   0D6H  ;PSW.6 - AUXILIARY CARRY FLAG
0000            101   CY     BIT   0D7H  ;PSW.7 - CARRY FLAG
0000            102   
0000            103   ; For the altera DE2 configured with an 8051/8052 softcore processor
0000            104   ; we have the following extra registers:
0000            105   
0000            106   HEX0   DATA  091H ; Zero turns the segment on
0000            107   HEX1   DATA  092H ; 
0000            108   HEX2   DATA  093H ; 
0000            109   HEX3   DATA  094H ; 
0000            110   HEX4   DATA  08EH ;
0000            111   HEX5   DATA  08FH ;
0000            112   HEX6   DATA  096H ;
0000            113   HEX7   DATA  097H ;
0000            114   
0000            115   P0MOD  DATA  09AH ; Input/output mode bits for port 0.  '1' sets the port to output mode.
0000            116   P1MOD  DATA  09BH ; Input/output mode bits for port 1
0000            117   P2MOD  DATA  09CH ; Input/output mode bits for port 2
0000            118   P3MOD  DATA  09DH ; Input/output mode bits for port 3
0000            119   
0000            120   LEDRA  DATA  0E8H ; LEDs LEDR0 to LEDR7 (bit addressable, ex: LEDRA.1 for LEDR1)
0000            121   LEDRB  DATA  095H ; LEDs LEDR8 to LEDR15
0000            122   LEDRC  DATA  09EH ; LEDs LEDR16, LEDR15, and LEDG8
0000            123   LEDG   DATA  0F8H ; LEDs LEDG0 to LEDG7 (bit addressable, ex: LEDG.3 for LEDG3)
0000            124   SWA    DATA  0E8H ; Switches SW0 to SW7 (bit addressable, ex: SWA.1 for SW1)
0000            125   SWB    DATA  095H ; Switches SW8 to SW15
0000            126   SWC    DATA  09EH ; Switches SW16 and SW17
0000            127   KEY    DATA  0F8H ; KEY1=KEY.1, KEY2=KEY.2, KEY3=KEY.3.  KEY0 is the reset button! 
0000            128   
0000            129   LCD_CMD   DATA 0D8H ;
0000            130   LCD_DATA  DATA 0D9H ;
0000            131   LCD_MOD   DATA 0DAH ; Write 0xff to make LCD_DATA an output
0000            132   LCD_RW    BIT  0D8H ; '0' writes to LCD
0000            133   LCD_EN    BIT  0D9H ; Toggle from '1' to '0'
0000            134   LCD_RS    BIT  0DAH ; '0' for commands, '1' for data
0000            135   LCD_ON    BIT  0DBH ; Write '1' to power the LCD
0000            136   LCD_BLON  BIT  0DCH ; Write '1' to turn on back light
0000            137   
0000            138   FLASH_CMD  data 0DBH ; The control bits of the flash memory:
0000            139   ; bit 0: FL_RST_N  Set to 1 for normal operation
0000            140   ; bit 1: FL_WE_N
0000            141   ; bit 2: FL_OE_N
0000            142   ; bit 3: FL_CE_N
0000            143   FLASH_DATA data 0DCH ; 8-bit data bus of flash memory.
0000            144   FLASH_MOD  data 0DDH ; 0xff makes FLASH_DATA output.  0x00 makes FLASH_DATA input.
0000            145   FLASH_ADD0 data 0E1H ; address bits 0 to 7.
0000            146   FLASH_ADD1 data 0E2H ; address bits 8 to 15.
0000            147   FLASH_ADD2 data 0E3H ; address bits 16 to 21.
0000            148   
0000              2   
0000              3            CSEG at 0
0000 0206A1       4            ljmp main_code
0003              5   
0030              6            DSEG at 30H
0030              7   bcd:     ds 5 ; 40 bits / 10 BCD digits (4 bits each)
0035              8   x: ds 4 ; num1, max size is 32 bits
0039              9   y: ds 4 ; num2, max size is 32 bits
003D             10   S: ds 4 ; for sqrt32
0041             11   ; num1: ds 4 ; max size is 32 bits
0041             12   ; num2: ds 4 ; max size is 32 bits
0041             13   entered_count: ds 1 ; number of digits entered so far
0042             14   
0000             15            bseg ; standard address 0x20h to 0x2F
0000             16   mf: dbit 1  ; TODO
0001             17   operationSetFlag: dbit 1 ; if operation key pressed
0002             18   errorFlag: dbit 1  ; if error occurred
0003             19   completeFlag: dbit 1 ; if calculation is complete
                 -1   $include(math32.asm)
                614   $LIST
02F5             21   
02F5             22            CSEG
02F5             23   
02F5             24   ; Look-up table for 7-seg displays
02F5             25   myLUT:
02F5 C0F9A4B0    26       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
02FA 9282F880    27       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
02FF 8883C6A1    28       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0305             29   
                 30   showBCD MAC
                 31   	; Display LSD
                 32       mov A, %0
                 33       anl a, #0fh
                 34       movc A, @A+dptr
                 35       mov %1, A
                 36   	; Display MSD
                 37       mov A, %0
                 38       swap a
                 39       anl a, #0fh
                 40       movc A, @A+dptr
                 41       mov %2, A
                 42   ENDMAC
0305             43   
0305             44   ; set errorFlag and display 'Error' on 7-seg displays
0305             45   setError:
0305 D202        46            setb errorFlag
0307 758FFF      47            mov  HEX5, #0xFF ; all off
030A 758E86      48       mov  HEX4, #0x86 ; 'E'
030D 7594CE      49       mov  HEX3, #0xCE ; 'r' 
0310 7593CE      50       mov  HEX2, #0xCE ; 'r' 
0313 7592C0      51       mov  HEX1, #0xC0 ; 'O' 
0316 7591CE      52       mov  HEX0, #0xCE ; 'r'
0319             53   
0319             54   ; error loop forever
0319             55   errorLoopForever:
0319 22          56            ret
031A             57   
031A             58   ; shows the 10-digit BCD number on the six 7-seg displays
031A             59   Display:
031A 9002F5      60            mov dptr, #myLUT
031D             61            
                 61   	$MESSAGE TIP: If digits 10, 9, 8, and 7 are not zero, LEDR7: on
031D             63            
031D E533        64            mov a, bcd+3
031F 4534        65            orl a, bcd+4
0321 6004        66            jz Display_L1
0323 D2EF        67            setb LEDRA.7 ; Non-zero digits alert
0325 8002        68            sjmp Display_L2
0327             69   Display_L1:
0327 C2EF        70            clr LEDRA.7
0329             71   Display_L2:
0329             72   
                 72   	$MESSAGE TIP: Pressing KEY3, displays the most significant digits of the 10-digit number
0329             74            
0329 30FB2F      75            jnb key.3, Display_high_digits
032C             76            ; Display LSD
032C E530        76       mov A, bcd+0
032E 540F        76       anl a, #0fh
0330 93          76       movc A, @A+dptr
0331 F591        76       mov HEX0, A
0333             76            ; Display MSD
0333 E530        76       mov A, bcd+0
0335 C4          76       swap a
0336 540F        76       anl a, #0fh
0338 93          76       movc A, @A+dptr
0339 F592        76       mov HEX1, A
033B             77            ; Display LSD
033B E531        77       mov A, bcd+1
033D 540F        77       anl a, #0fh
033F 93          77       movc A, @A+dptr
0340 F593        77       mov HEX2, A
0342             77            ; Display MSD
0342 E531        77       mov A, bcd+1
0344 C4          77       swap a
0345 540F        77       anl a, #0fh
0347 93          77       movc A, @A+dptr
0348 F594        77       mov HEX3, A
034A             78            ; Display LSD
034A E532        78       mov A, bcd+2
034C 540F        78       anl a, #0fh
034E 93          78       movc A, @A+dptr
034F F58E        78       mov HEX4, A
0351             78            ; Display MSD
0351 E532        78       mov A, bcd+2
0353 C4          78       swap a
0354 540F        78       anl a, #0fh
0356 93          78       movc A, @A+dptr
0357 F58F        78       mov HEX5, A
0359 8024        79            sjmp Display_end
035B             80   
035B             81   Display_high_digits:
035B             82            ; Display LSD
035B E533        82       mov A, bcd+3
035D 540F        82       anl a, #0fh
035F 93          82       movc A, @A+dptr
0360 F591        82       mov HEX0, A
0362             82            ; Display MSD
0362 E533        82       mov A, bcd+3
0364 C4          82       swap a
0365 540F        82       anl a, #0fh
0367 93          82       movc A, @A+dptr
0368 F592        82       mov HEX1, A
036A             83            ; Display LSD
036A E534        83       mov A, bcd+4
036C 540F        83       anl a, #0fh
036E 93          83       movc A, @A+dptr
036F F593        83       mov HEX2, A
0371             83            ; Display MSD
0371 E534        83       mov A, bcd+4
0373 C4          83       swap a
0374 540F        83       anl a, #0fh
0376 93          83       movc A, @A+dptr
0377 F594        83       mov HEX3, A
0379 758EFF      84            mov HEX4, #0xff         
037C 758FFF      85            mov HEX5, #0xff         
037F             86            
037F             87   Display_end:
037F 22          88       ret
0380             89   
0380             90   ; rotates a bit left through carry
                 91   MYRLC MAC
                 92   	mov a, %0
                 93   	rlc a
                 94   	mov %0, a
                 95   ENDMAC
0380             96   
0380             97   ; shifts bcd left by one digit
0380             98   Shift_Digits_Left:
0380 7804        99            mov R0, #4 ; shift left four bits
0382            100   Shift_Digits_Left_L0:
0382 C3         101            clr c
0383 E530       102            mov a, bcd+0
0385 33         102            rlc a
0386 F530       102            mov bcd+0, a
0388 E531       103            mov a, bcd+1
038A 33         103            rlc a
038B F531       103            mov bcd+1, a
038D E532       104            mov a, bcd+2
038F 33         104            rlc a
0390 F532       104            mov bcd+2, a
0392 E533       105            mov a, bcd+3
0394 33         105            rlc a
0395 F533       105            mov bcd+3, a
0397 E534       106            mov a, bcd+4
0399 33         106            rlc a
039A F534       106            mov bcd+4, a
039C D8E4       107            djnz R0, Shift_Digits_Left_L0
039E            108            ; R7 has the new bcd digit      
039E EF         109            mov a, R7
039F 4530       110            orl a, bcd+0
03A1 F530       111            mov bcd+0, a
03A3 22         112            ret
03A4            113            
03A4            114   ; rotates a bit right through carry
                115   MYRRC MAC
                116   	mov a, %0
                117   	rrc a
                118   	mov %0, a
                119   ENDMAC
03A4            120   
03A4            121   ; shifts bcd right by one digit
03A4            122   Shift_Digits_Right:
03A4 7804       123            mov R0, #4 ; shift right four bits
03A6            124   Shift_Digits_Right_L0:
03A6 C3         125            clr c
03A7 E534       126            mov a, bcd+4
03A9 13         126            rrc a
03AA F534       126            mov bcd+4, a
03AC E533       127            mov a, bcd+3
03AE 13         127            rrc a
03AF F533       127            mov bcd+3, a
03B1 E532       128            mov a, bcd+2
03B3 13         128            rrc a
03B4 F532       128            mov bcd+2, a
03B6 E531       129            mov a, bcd+1
03B8 13         129            rrc a
03B9 F531       129            mov bcd+1, a
03BB E530       130            mov a, bcd+0
03BD 13         130            rrc a
03BE F530       130            mov bcd+0, a
03C0 D8E4       131            djnz R0, Shift_Digits_Right_L0
03C2 22         132            ret
03C3            133   
03C3            134   ; waits for 50ms
03C3            135   Wait50ms:
03C3            136   ;33.33MHz, 1 clk per cycle: 0.03us
03C3 785A       137            mov R0, #90
03C5 794A       138   L3: mov R1, #74
03C7 7AFA       139   L2: mov R2, #250
03C9 DAFE       140   L1: djnz R2, L1 ;3*250*0.03us=22.5us
03CB D9FA       141       djnz R1, L2 ;74*22.5us=1.665ms
03CD D8F6       142       djnz R0, L3 ;1.665ms*30=50ms
03CF 22         143       ret
03D0            144   
03D0            145   ; checks if a key is pressed in the column
                146   CHECK_COLUMN MAC
                147   	jb %0, CHECK_COL_%M
                148   	mov R7, %1
                149   	jnb %0, $ ; wait for key release
                150   	setb c
                151   	ret
                152   CHECK_COL_%M:
                153   ENDMAC
03D0            154   
03D0            155   Configure_Keypad_Pins:
03D0            156            ; Configure the row pins as output and the column pins as inputs
03D0 439B54     157            orl P1MOD, #0b_01010100 ; P1.6, P1.4, P1.2 output
03D3 439C01     158            orl P2MOD, #0b_00000001 ; P2.0 output
03D6 539CAB     159            anl P2MOD, #0b_10101011 ; P2.6, P2.4, P2.2 input
03D9 539DFE     160            anl P3MOD, #0b_11111110 ; P3.0 input
03DC 22         161            ret
03DD            162   
03DD            163   ; These are the pins used for the keypad in this program:
03DD            164   ROW1 EQU P1.2
03DD            165   ROW2 EQU P1.4
03DD            166   ROW3 EQU P1.6
03DD            167   ROw4 EQU P2.0
03DD            168   COL1 EQU P2.2
03DD            169   COL2 EQU P2.4
03DD            170   COL3 EQU P2.6
03DD            171   COL4 EQU P3.0
03DD            172   
03DD            173   ; This subroutine scans a 4x4 keypad.  If a key is pressed sets the carry
03DD            174   ; to one and returns the key code in register R7.
03DD            175   ; It works with both a default keypad or a modified keypad with the labels
03DD            176   ; rotated 90 deg ccw.  The type of keypad is determined by SW0, which is bit SWA.0
03DD            177   
03DD            178   ; HOW IT WORKS (shuyu added)
03DD            179   ; set all rows low
03DD            180   ; check all column inputs
03DD            181   ; if all high, no key pressed
03DD            182   ; if low, some key pressed in that column
03DD            183   ; scan each row one at a time by setting low and checking columns
03DD            184   ; if low, key at that row+column combination is pressed
03DD            185   Keypad:
03DD            186            ; First check the backspace/correction pushbutton.  We use KEY1 for this function.
                186   	$MESSAGE TIP: KEY1 is the erase key
03DD 20F90E     188            jb KEY.1, keypad_L0
03E0 1203C3     189            lcall Wait50ms ; debounce
03E3 20F908     190            jb KEY.1, keypad_L0
03E6 30F9FD     191            jnb KEY.1, $ ; The key was pressed, wait for release
03E9 1203A4     192            lcall Shift_Digits_Right
03EC C3         193            clr c
03ED 22         194            ret
03EE            195            
03EE            196   keypad_L0:
03EE            197            ; Make all the rows zero.  If any column is zero then a key is pressed.
03EE C292       198            clr ROW1
03F0 C294       199            clr ROW2
03F2 C296       200            clr ROW3
03F4 C2A0       201            clr ROW4
03F6 A2A2       202            mov c, COL1
03F8 82A4       203            anl c, COL2
03FA 82A6       204            anl c, COL3
03FC 82B0       205            anl c, COL4
03FE 5002       206            jnc Keypad_Debounce
0400 C3         207            clr c
0401 22         208            ret
0402            209                    
0402            210   Keypad_Debounce:
0402            211            ; A key maybe pressed.  Wait and check again to discard bounces.
0402 1203C3     212            lcall Wait50ms ; debounce
0405 A2A2       213            mov c, COL1
0407 82A4       214            anl c, COL2
0409 82A6       215            anl c, COL3
040B 82B0       216            anl c, COL4
040D 5002       217            jnc Keypad_Key_Code
040F C3         218            clr c
0410 22         219            ret
0411            220            
0411            221   Keypad_Key_Code:         
0411            222            ; A key is pressed.  Find out which one by checking each possible column and row combination.
0411            223   
0411 D292       224            setb ROW1
0413 D294       225            setb ROW2
0415 D296       226            setb ROW3
0417 D2A0       227            setb ROW4
0419            228            
                228   	$MESSAGE TIP: SW0 is used to control the layout of the keypad. SW0=0: unmodified keypad. SW0=1: keypad rotated 90 deg CCW
0419            230   
0419 30E803     231            jnb SWA.0, keypad_default
041C 0204D1     232            ljmp keypad_90deg
041F            233            
041F            234            ; This check section is for an un-modified keypad
041F            235   keypad_default:  
041F            236            ; Check row 1   
041F C292       237            clr ROW1
0421 20A207     238            jb COL1, CHECK_COL_16
0424 7F01       238            mov R7, #01H
0426 30A2FD     238            jnb COL1, $ ; wait for key release
0429 D3         238            setb c
042A 22         238            ret
042B            238   CHECK_COL_16:
042B 20A407     239            jb COL2, CHECK_COL_17
042E 7F02       239            mov R7, #02H
0430 30A4FD     239            jnb COL2, $ ; wait for key release
0433 D3         239            setb c
0434 22         239            ret
0435            239   CHECK_COL_17:
0435 20A607     240            jb COL3, CHECK_COL_18
0438 7F03       240            mov R7, #03H
043A 30A6FD     240            jnb COL3, $ ; wait for key release
043D D3         240            setb c
043E 22         240            ret
043F            240   CHECK_COL_18:
043F 20B007     241            jb COL4, CHECK_COL_19
0442 7F0A       241            mov R7, #0AH
0444 30B0FD     241            jnb COL4, $ ; wait for key release
0447 D3         241            setb c
0448 22         241            ret
0449            241   CHECK_COL_19:
0449 D292       242            setb ROW1
044B            243   
044B            244            ; Check row 2   
044B C294       245            clr ROW2
044D 20A207     246            jb COL1, CHECK_COL_20
0450 7F04       246            mov R7, #04H
0452 30A2FD     246            jnb COL1, $ ; wait for key release
0455 D3         246            setb c
0456 22         246            ret
0457            246   CHECK_COL_20:
0457 20A407     247            jb COL2, CHECK_COL_21
045A 7F05       247            mov R7, #05H
045C 30A4FD     247            jnb COL2, $ ; wait for key release
045F D3         247            setb c
0460 22         247            ret
0461            247   CHECK_COL_21:
0461 20A607     248            jb COL3, CHECK_COL_22
0464 7F06       248            mov R7, #06H
0466 30A6FD     248            jnb COL3, $ ; wait for key release
0469 D3         248            setb c
046A 22         248            ret
046B            248   CHECK_COL_22:
046B 20B007     249            jb COL4, CHECK_COL_23
046E 7F0B       249            mov R7, #0BH
0470 30B0FD     249            jnb COL4, $ ; wait for key release
0473 D3         249            setb c
0474 22         249            ret
0475            249   CHECK_COL_23:
0475 D294       250            setb ROW2
0477            251   
0477            252            ; Check row 3   
0477 C296       253            clr ROW3
0479 20A207     254            jb COL1, CHECK_COL_24
047C 7F07       254            mov R7, #07H
047E 30A2FD     254            jnb COL1, $ ; wait for key release
0481 D3         254            setb c
0482 22         254            ret
0483            254   CHECK_COL_24:
0483 20A407     255            jb COL2, CHECK_COL_25
0486 7F08       255            mov R7, #08H
0488 30A4FD     255            jnb COL2, $ ; wait for key release
048B D3         255            setb c
048C 22         255            ret
048D            255   CHECK_COL_25:
048D 20A607     256            jb COL3, CHECK_COL_26
0490 7F09       256            mov R7, #09H
0492 30A6FD     256            jnb COL3, $ ; wait for key release
0495 D3         256            setb c
0496 22         256            ret
0497            256   CHECK_COL_26:
0497 20B007     257            jb COL4, CHECK_COL_27
049A 7F0C       257            mov R7, #0CH
049C 30B0FD     257            jnb COL4, $ ; wait for key release
049F D3         257            setb c
04A0 22         257            ret
04A1            257   CHECK_COL_27:
04A1 D296       258            setb ROW3
04A3            259   
04A3            260            ; Check row 4   
04A3 C2A0       261            clr ROW4
04A5 20A207     262            jb COL1, CHECK_COL_28
04A8 7F0E       262            mov R7, #0EH
04AA 30A2FD     262            jnb COL1, $ ; wait for key release
04AD D3         262            setb c
04AE 22         262            ret
04AF            262   CHECK_COL_28: ; E = *
04AF 20A407     263            jb COL2, CHECK_COL_29
04B2 7F00       263            mov R7, #00H
04B4 30A4FD     263            jnb COL2, $ ; wait for key release
04B7 D3         263            setb c
04B8 22         263            ret
04B9            263   CHECK_COL_29:
04B9 20A607     264            jb COL3, CHECK_COL_30
04BC 7F0F       264            mov R7, #0FH
04BE 30A6FD     264            jnb COL3, $ ; wait for key release
04C1 D3         264            setb c
04C2 22         264            ret
04C3            264   CHECK_COL_30: ; F = #
04C3 20B007     265            jb COL4, CHECK_COL_31
04C6 7F0D       265            mov R7, #0DH
04C8 30B0FD     265            jnb COL4, $ ; wait for key release
04CB D3         265            setb c
04CC 22         265            ret
04CD            265   CHECK_COL_31:
04CD D2A0       266            setb ROW4
04CF            267   
04CF C3         268            clr c
04D0 22         269            ret
04D1            270            
04D1            271            ; This check section is for a keypad with the labels rotated 90 deg ccw
04D1            272   keypad_90deg:
04D1            273            ; Check row 1   
04D1 C292       274            clr ROW1
04D3 20A207     275            jb COL1, CHECK_COL_32
04D6 7F0A       275            mov R7, #0AH
04D8 30A2FD     275            jnb COL1, $ ; wait for key release
04DB D3         275            setb c
04DC 22         275            ret
04DD            275   CHECK_COL_32:
04DD 20A407     276            jb COL2, CHECK_COL_33
04E0 7F0B       276            mov R7, #0BH
04E2 30A4FD     276            jnb COL2, $ ; wait for key release
04E5 D3         276            setb c
04E6 22         276            ret
04E7            276   CHECK_COL_33:
04E7 20A607     277            jb COL3, CHECK_COL_34
04EA 7F0C       277            mov R7, #0CH
04EC 30A6FD     277            jnb COL3, $ ; wait for key release
04EF D3         277            setb c
04F0 22         277            ret
04F1            277   CHECK_COL_34:
04F1 20B007     278            jb COL4, CHECK_COL_35
04F4 7F0D       278            mov R7, #0DH
04F6 30B0FD     278            jnb COL4, $ ; wait for key release
04F9 D3         278            setb c
04FA 22         278            ret
04FB            278   CHECK_COL_35:
04FB D292       279            setb ROW1
04FD            280   
04FD            281            ; Check row 2   
04FD C294       282            clr ROW2
04FF 20A207     283            jb COL1, CHECK_COL_36
0502 7F03       283            mov R7, #03H
0504 30A2FD     283            jnb COL1, $ ; wait for key release
0507 D3         283            setb c
0508 22         283            ret
0509            283   CHECK_COL_36:
0509 20A407     284            jb COL2, CHECK_COL_37
050C 7F06       284            mov R7, #06H
050E 30A4FD     284            jnb COL2, $ ; wait for key release
0511 D3         284            setb c
0512 22         284            ret
0513            284   CHECK_COL_37:
0513 20A607     285            jb COL3, CHECK_COL_38
0516 7F09       285            mov R7, #09H
0518 30A6FD     285            jnb COL3, $ ; wait for key release
051B D3         285            setb c
051C 22         285            ret
051D            285   CHECK_COL_38:
051D 20B007     286            jb COL4, CHECK_COL_39
0520 7F0F       286            mov R7, #0FH
0522 30B0FD     286            jnb COL4, $ ; wait for key release
0525 D3         286            setb c
0526 22         286            ret
0527            286   CHECK_COL_39:
0527 D294       287            setb ROW2
0529            288   
0529            289            ; Check row 3   
0529 C296       290            clr ROW3
052B 20A207     291            jb COL1, CHECK_COL_40
052E 7F02       291            mov R7, #02H
0530 30A2FD     291            jnb COL1, $ ; wait for key release
0533 D3         291            setb c
0534 22         291            ret
0535            291   CHECK_COL_40:
0535 20A407     292            jb COL2, CHECK_COL_41
0538 7F05       292            mov R7, #05H
053A 30A4FD     292            jnb COL2, $ ; wait for key release
053D D3         292            setb c
053E 22         292            ret
053F            292   CHECK_COL_41:
053F 20A607     293            jb COL3, CHECK_COL_42
0542 7F08       293            mov R7, #08H
0544 30A6FD     293            jnb COL3, $ ; wait for key release
0547 D3         293            setb c
0548 22         293            ret
0549            293   CHECK_COL_42:
0549 20B007     294            jb COL4, CHECK_COL_43
054C 7F00       294            mov R7, #00H
054E 30B0FD     294            jnb COL4, $ ; wait for key release
0551 D3         294            setb c
0552 22         294            ret
0553            294   CHECK_COL_43:
0553 D296       295            setb ROW3
0555            296   
0555            297            ; Check row 4   
0555 C2A0       298            clr ROW4
0557 20A207     299            jb COL1, CHECK_COL_44
055A 7F01       299            mov R7, #01H
055C 30A2FD     299            jnb COL1, $ ; wait for key release
055F D3         299            setb c
0560 22         299            ret
0561            299   CHECK_COL_44:
0561 20A407     300            jb COL2, CHECK_COL_45
0564 7F04       300            mov R7, #04H
0566 30A4FD     300            jnb COL2, $ ; wait for key release
0569 D3         300            setb c
056A 22         300            ret
056B            300   CHECK_COL_45:
056B 20A607     301            jb COL3, CHECK_COL_46
056E 7F07       301            mov R7, #07H
0570 30A6FD     301            jnb COL3, $ ; wait for key release
0573 D3         301            setb c
0574 22         301            ret
0575            301   CHECK_COL_46:
0575 20B007     302            jb COL4, CHECK_COL_47
0578 7F0E       302            mov R7, #0EH
057A 30B0FD     302            jnb COL4, $ ; wait for key release
057D D3         302            setb c
057E 22         302            ret
057F            302   CHECK_COL_47:
057F D2A0       303            setb ROW4
0581            304   
0581 C3         305            clr c
0582 22         306            ret
0583            307   
0583            308   ; checks if operation key pressed, if so, set display to all zeroes
0583            309   check_add_pressed:
0583 BF0A08     310            cjne R7, #0AH, check_sub_pressed ; "A" key for + operation
0586 75F000     311            mov b, #0 ; b = 0 for addition
0589 D201       312            setb operationSetFlag
058B 0205CA     313            ljmp copy_value_to_x_and_zero_displays
058E            314   
058E            315   check_sub_pressed:
058E BF0B08     316            cjne R7, #0BH, check_root_pressed ; "B" key for - operation
0591 75F001     317            mov b, #1 ; b = 1 for subtraction
0594 D201       318            setb operationSetFlag
0596 0205CA     319            ljmp copy_value_to_x_and_zero_displays 
0599            320   
0599            321   check_root_pressed:
0599 BF0C08     322            cjne R7, #0CH, check_div_pressed ; "C" key for root operation
059C 75F002     323            mov b, #2 ; b = 2 for root
059F D201       324            setb operationSetFlag
05A1 0205CA     325            ljmp copy_value_to_x_and_zero_displays 
05A4            326   
05A4            327   check_div_pressed:
05A4 BF0D08     328            cjne R7, #0DH, check_mul_pressed ; "D" key for division
05A7 75F003     329            mov b, #3 ; b = 3 for division
05AA D201       330            setb operationSetFlag
05AC 0205CA     331            ljmp copy_value_to_x_and_zero_displays ; 
05AF            332   
05AF            333   check_mul_pressed:
05AF BF0E08     334            cjne R7, #0EH, check_enter_pressed ; "*" key for multiplication
05B2 75F004     335            mov b, #4 ; b = 4 for multiplication
05B5 D201       336            setb operationSetFlag
05B7 0205CA     337            ljmp copy_value_to_x_and_zero_displays 
05BA            338   
05BA            339   check_enter_pressed:
05BA BF0F0A     340            cjne R7, #0FH, back_to_forever ; "#" key for = operation
05BD 300107     341            jnb operationSetFlag, back_to_forever ; if no operation set, ignore
05C0 C201       342            clr operationSetFlag
05C2 E5F0       343            mov a, b ; move operation value (set above) into a
05C4 1205E8     344            lcall check_add_operation ; start performing operations!
05C7            345   
05C7            346   back_to_forever:
05C7 0206BC     347            ljmp forever
05CA            348   
05CA            349   copy_value_to_x_and_zero_displays:
05CA 120050     350            lcall bcd2hex ; converts 10 digits in bcd to 32 bits in x
05CD 20007B     351            jb mf, handle_overflow ; if carry bit set, overflow error
05D0 1202CF     352            lcall copy_xy ; copies x to y
05D3 753500     353            mov x+0, #low (0 % 0x10000) 
05D6 753600     353            mov x+1, #high(0 % 0x10000) 
05D9 753700     353            mov x+2, #low (0 / 0x10000) 
05DC 753800     353            mov x+3, #high(0 / 0x10000)  ; sets x to 0
05DF 120003     354            lcall hex2bcd ; sets bcd to 0
05E2 12031A     355            lcall Display ; displays all zeroes
05E5 0206BC     356            ljmp forever ; back to forever
05E8            357   
05E8            358   check_add_operation:
05E8 B4000F     359            cjne a, #0, check_sub_operation
05EB 120050     360            lcall bcd2hex ; load num2 into x
05EE 20005A     361            jb mf, handle_overflow
05F1 1200A8     362            lcall add32 ; x = x + y
05F4 200054     363            jb mf, handle_overflow ; overflow error
05F7 020657     364            ljmp display_positive_x
05FA            365   
05FA            366   check_sub_operation:
05FA B40114     367            cjne a, #1, check_root_operation
05FD 120050     368            lcall bcd2hex ; load num2 into x
0600 200048     369            jb mf, handle_overflow
0603 1202DC     370            lcall xchg_xy ; swap x and y, since y was first num, x is second num
0606 1200CB     371            lcall sub32 ; x = x - y
0609 E538       372            mov a, x+3 ; if bit 7 = 1 (sign bit) display negative
060B 20E756     373            jb ACC.7, display_negative_x
060E 020657     374            ljmp display_positive_x
0611            375   
0611            376   check_root_operation:
0611 B40209     377            cjne a, #2, check_div_operation
0614 1202DC     378            lcall xchg_xy ; swap x and y, since y was first num, x is second num
0617 12072B     379            lcall sqrt32  ; perform integer sqrt (defined at bottom)
061A 020657     380            ljmp display_positive_x
061D            381   
061D            382   check_div_operation:
061D B40319     383            cjne a, #3, check_mul_operation
0620 120050     384            lcall bcd2hex ; load num2 into x
0623 200025     385            jb mf, handle_overflow
0626            386   
0626 E535       387            mov a, x+0
0628 4536       388            orl a, x+1 
062A 4537       389            orl a, x+2
062C 4538       390            orl a, x+3
062E 6021       391            jz handle_div_by_zero ; if all bits of x are zero, error
0630            392            
0630 1202DC     393            lcall xchg_xy ; swap x and y, since y was first num, x is second num 
0633 120255     394            lcall div32 ; x = x / y
0636 020657     395            ljmp display_positive_x
0639            396   
0639            397   check_mul_operation:
0639 B4048B     398            cjne a, #4, back_to_forever
063C 120050     399            lcall bcd2hex ; load num2 into x
063F 200009     400            jb mf, handle_overflow
0642 120161     401            lcall mul32 ; x = x * y
0645 200003     402            jb mf, handle_overflow ; if carry bit set, overflow error
0648 020657     403            ljmp display_positive_x
064B            404   
064B            405   handle_overflow:
064B            406            ; set error flag and display 'E' on all 7-seg displays
064B 120305     407            lcall setError
064E 020319     408            ljmp errorLoopForever
0651            409   
0651            410   handle_div_by_zero: 
0651            411            ; set error flag and display 'E' on all 7-seg displays
0651 120305     412            lcall setError
0654 020319     413            ljmp errorLoopForever
0657            414   
0657            415   display_positive_x:
0657 D203       416            setb completeFlag
0659 C2E8       417            clr LEDRA.0 
065B 120003     418            lcall hex2bcd
065E            419            ; jb mf, handle_overflow ; if carry bit set, overflow error
065E 12031A     420            lcall Display
0661 0206BC     421            ljmp forever
0664            422   
0664            423   display_negative_x:
0664 D203       424            setb completeFlag
0666 D2E8       425            setb LEDRA.0
0668 120674     426            lcall twos_complement_x
066B 120003     427            lcall hex2bcd
066E            428            ; jb mf, handle_overflow ; if carry bit set, overflow error
066E 12031A     429            lcall Display
0671 0206BC     430            ljmp forever
0674            431   
0674            432   twos_complement_x:
0674            433            ; complement each bit
0674 E535       434            mov a, x+0
0676 F4         435            cpl a 
0677 F535       436            mov x+0, a
0679 E536       437            mov a, x+1
067B F4         438            cpl a
067C F536       439            mov x+1, a
067E E537       440            mov a, x+2
0680 F4         441            cpl a
0681 F537       442            mov x+2, a
0683 E538       443            mov a, x+3
0685 F4         444            cpl a
0686 F538       445            mov x+3, a
0688            446   
0688            447            ; add 1 and carry through
0688 7401       448            mov a, #1
068A 2535       449            add a, x+0
068C F535       450            mov x+0, a
068E 7400       451            mov a, #0
0690 3536       452            addc a, x+1
0692 F536       453            mov x+1, a
0694 7400       454            mov a, #0
0696 3537       455            addc a, x+2
0698 F537       456            mov x+2, a
069A 7400       457            mov a, #0
069C 3538       458            addc a, x+3
069E F538       459            mov x+3, a
06A0 22         460            ret
06A1            461            
06A1            462   main_code:
06A1 75817F     463            mov SP, #7FH
06A4 E4         464            clr a
06A5 F5E8       465            mov LEDRA, a
06A7 F595       466            mov LEDRB, a
06A9 F530       467            mov bcd+0, a
06AB F531       468            mov bcd+1, a
06AD F532       469            mov bcd+2, a
06AF F533       470            mov bcd+3, a
06B1 F534       471            mov bcd+4, a
06B3 F541       472            mov entered_count, a
06B5 C203       473            clr completeFlag
06B7 C202       474            clr errorFlag
06B9 1203D0     475            lcall Configure_Keypad_Pins
06BC            476   
06BC            477   forever:
06BC 1203DD     478            lcall Keypad
06BF 200203     479            jb errorFlag, skip_display
06C2 12031A     480            lcall Display
06C5            481   
06C5            482   skip_display:
06C5 50F5       483            jnc forever
06C7            484   
06C7            485            ; If errorFlag is set, only allow digits 0–9
06C7 200222     486            jb errorFlag, error_digit_check
06CA            487   
06CA 7409       488            mov a, #9
06CC C3         489            clr c
06CD 9F         490            subb a, R7
06CE            491   
06CE 4042       492            jc operation_entered ; if R7 > 9 (not 0-9) call operation
06D0            493   
06D0 300348     494            jnb completeFlag, digit_entered ; if we didn't just have calculation completed
06D3            495   
06D3            496            ; if calculation is complete and new digit entered, erase calculation and enter digit
06D3 753500     497            mov x+0, #low (0 % 0x10000) 
06D6 753600     497            mov x+1, #high(0 % 0x10000) 
06D9 753700     497            mov x+2, #low (0 / 0x10000) 
06DC 753800     497            mov x+3, #high(0 / 0x10000) 
06DF 120003     498            lcall hex2bcd ; set bcd to 0
06E2 C2E8       499            clr LEDRA.0 ; turn off negative LED
06E4 C203       500            clr completeFlag ; clear complete flag
06E6 754100     501            mov entered_count, #0 ; reset number of digits entered
06E9 12071B     502            lcall digit_entered ; process new digit
06EC            503   
06EC            504   error_digit_check:
06EC 7409       505            mov a, #9
06EE C3         506            clr c
06EF 9F         507            subb a, R7
06F0 40CA       508            jc forever ; ignore operation keys if in error state
06F2            509   
06F2 C202       510            clr errorFlag
06F4 C2E8       511            clr LEDRA.0
06F6 C203       512            clr completeFlag
06F8 754101     513            mov entered_count, #1
06FB            514   
06FB 753500     515            mov x+0, #low (0 % 0x10000) 
06FE 753600     515            mov x+1, #high(0 % 0x10000) 
0701 753700     515            mov x+2, #low (0 / 0x10000) 
0704 753800     515            mov x+3, #high(0 / 0x10000) 
0707            516            ; lcall hex2bcd
0707 120380     517            lcall Shift_Digits_Left
070A EF         518            mov a, R7
070B 4530       519            orl a, bcd+0
070D F530       520            mov bcd+0, a
070F            521   
070F 0206BC     522            ljmp forever
0712            523   
0712            524   operation_entered:
0712 754100     525            mov entered_count, #0 ; reset number of digits entered
0715 120583     526            lcall check_add_pressed
0718 0206BC     527            ljmp forever
071B            528   
071B            529   digit_entered:
071B 0541       530            inc entered_count ; increment number of digits entered
071D E541       531            mov a, entered_count
071F B40B03     532            cjne a, #11, digits_entered_continue
0722 02064B     533            ljmp handle_overflow ; if more than 10 digits entered, overflow error
0725            534   
0725            535   ; digits_entered_continue:
0725            536   ;        cjne a, #10, digits_entered_continue2
0725            537   ;        lcall Shift_Digits_Left
0725            538   ;        lcall check_overflow
0725            539   ;        ljmp forever
0725            540   
0725            541   digits_entered_continue:
0725            542            ; shift digits left
0725 120380     543            lcall Shift_Digits_Left
0728 0206BC     544            ljmp forever
072B            545   
072B            546   ; check_overflow:
072B            547   ;        ; check if value in bcd > 4294967295
072B            548   ;        ; check MSB first
072B            549   ;     mov  A, bcd+4
072B            550   ;     clr  C
072B            551   ;     subb A, #0x42
072B            552   ;     jnc  not_less_4
072B            553   ;     ret ; bcd bit 4 < 0x42 -- fine
072B            554   ; not_less_4:
072B            555   ;     jnz  handle_decimal_overflow ; bcd bit 4 > 0x42 -- overflow
072B            556   
072B            557   ;     mov  A, bcd+3
072B            558   ;     clr  C
072B            559   ;     subb A, #0x94
072B            560   ;     jnc  not_less_3
072B            561   ;     ret ; bcd bit 3 < 0x94 -- fine
072B            562   ; not_less_3:
072B            563   ;     jnz  handle_decimal_overflow ; bcd bit 3 > 0x94 -- overflow
072B            564   
072B            565   ;     mov  A, bcd+2
072B            566   ;     clr  C
072B            567   ;     subb A, #0x96
072B            568   ;     jnc  not_less_2
072B            569   ;     ret ; bcd bit 2 < 0x96 -- fine
072B            570   ; not_less_2:
072B            571   ;     jnz  handle_decimal_overflow ; bcd bit 2 > 0x96 -- overflow
072B            572   
072B            573   ;     mov  A, bcd+1
072B            574   ;     clr  C
072B            575   ;     subb A, #0x72
072B            576   ;     jnc  not_less_1
072B            577   ;     ret ; bcd bit 1 < 0x72 -- fine
072B            578   ; not_less_1:
072B            579   ;     jnz  handle_decimal_overflow ; bcd bit 1 > 0x72 -- overflow
072B            580   
072B            581   ;     mov  A, bcd+0
072B            582   ;     clr  C
072B            583   ;     subb A, #0x95
072B            584   ;     jnc  not_less_0
072B            585   ;     ret ; bcd bit 0 < 0x95 -- fine
072B            586   ; not_less_0:
072B            587   ;     jnz  handle_decimal_overflow ; bcd bit 0 > 0x95 -- overflow
072B            588   
072B            589   ;     ; If exactly equal to 4294967295 -- fine
072B            590   ;     ret
072B            591   
072B            592   ; handle_decimal_overflow:
072B            593   ;        ; set error flag and display 'E' on all 7-seg displays
072B            594   ;        lcall setError
072B            595   ;        ljmp errorLoopForever
072B            596   
072B            597   ; ;------------------------------------------------
072B            598   ; ; sqrt32:
072B            599   ; ;   Calculates integer sqrt(x) using simple method
072B            600   ; ;------------------------------------------------
072B            601   ; sqrt32:
072B            602   ;        ; first save original x to R4–R7
072B            603   ;        mov R4, x+0
072B            604   ;        mov R5, x+1
072B            605   ;        mov R6, x+2
072B            606   ;        mov R7, x+3
072B            607   
072B            608   ; sqrt32_loop:
072B            609   ;        ; copy x into R0-R3 for working
072B            610   ;        mov R0, x+0
072B            611   ;        mov R1, x+1
072B            612   ;        mov R2, x+2
072B            613   ;        mov R3, x+3
072B            614   
072B            615   ;        ; compute x^2
072B            616   ;        lcall copy_xy ; y = x
072B            617   ;        lcall mul32 ; x = x*y = x^2
072B            618   
072B            619   ;        ; restore original x to y for comparison
072B            620   ;        mov y+0, R4
072B            621   ;        mov y+1, R5
072B            622   ;        mov y+2, R6
072B            623   ;        mov y+3, R7
072B            624   
072B            625   ;        lcall x_lteq_y ; sets mf if x^2 <= y
072B            626   
072B            627   ;        ; restore current x from R0-R3 (since prev. set x = x^2) 
072B            628   ;        mov x+0, R0
072B            629   ;        mov x+1, R1
072B            630   ;        mov x+2, R2
072B            631   ;        mov x+3, R3
072B            632   
072B            633   ;        ; if x^2 <= y, then x = isqrt(original x)
072B            634   ;        jb mf, done_sqrt32 
072B            635   
072B            636   ;        ; otherwise decrement x by 1 and try again
072B            637   ;        Load_y(1) ; y = 1
072B            638   ;        lcall sub32 ; x = x - 1
072B            639   ;        sjmp sqrt32_loop
072B            640   
072B            641   ; done_sqrt32:
072B            642   ;        ret
072B            643   
072B            644   ;------------------------------------------------
072B            645   ; sqrt32:
072B            646   ;   Calculates integer sqrt(x) using Heron's method
072B            647   ;------------------------------------------------
072B            648   sqrt32:
072B C0E0       649       push acc
072D C0D0       650       push psw
072F C000       651       push ar0
0731 C001       652       push ar1
0733 C002       653       push ar2
0735 C003       654       push ar3
0737 C004       655       push ar4
0739            656   
0739            657       ; if x==0 done
0739 E535       658       mov   a, x+0
073B 4536       659       orl   a, x+1
073D 4537       660       orl   a, x+2
073F 4538       661       orl   a, x+3
0741 7002       662       jnz   not_zero
0743 8057       663       sjmp  sqrt32_done
0745            664   
0745            665   not_zero:
0745            666       ; if x==1 done
0745 E535       667       mov  A, x+0
0747 B4010A     668            cjne A, #1, skip_check_one
074A E536       669       mov   a, x+1
074C 4537       670       orl   a, x+2
074E 4538       671       orl   a, x+3
0750 7002       672       jnz   skip_check_one
0752 8048       673       sjmp  sqrt32_done
0754            674   
0754            675   skip_check_one:
0754            676       ; save original input x into S
0754 85353D     677       mov   S+0, x+0
0757 85363E     678       mov   S+1, x+1
075A 85373F     679       mov   S+2, x+2
075D 853840     680       mov   S+3, x+3
0760            681   
0760            682       ; for initial guess shift x right by 1
0760 E538       683       mov   a, x+3
0762 13         684       rrc   a
0763 F538       685       mov   x+3, a
0765 E537       686       mov   a, x+2
0767 13         687       rrc   a
0768 F537       688       mov   x+2, a
076A E536       689       mov   a, x+1
076C 13         690       rrc   a
076D F536       691       mov   x+1, a
076F E535       692       mov   a, x+0
0771 13         693       rrc   a
0772 F535       694       mov   x+0, a
0774            695   
0774            696       ; 20 iterations
0774 7814       697       mov   r0, #20   ; iteration count
0776            698   
0776            699   sqrt32_loop:
0776            700       ; y = guess
0776 1202CF     701       lcall copy_xy  ; (y = x)
0779            702   
0779            703       ; x = S
0779 853D35     704       mov   x+0, S+0
077C 853E36     705       mov   x+1, S+1
077F 853F37     706       mov   x+2, S+2
0782 854038     707       mov   x+3, S+3
0785            708   
0785            709       ; x = x / y => x = S / guess
0785 120255     710       lcall div32
0788            711   
0788            712       ; x = x + guess => (S / guess) + guess
0788 1200A8     713       lcall add32
078B            714   
078B            715       ; x = x / 2
078B 753902     716            mov y+0, #low (2 % 0x10000) 
078E 753A00     716            mov y+1, #high(2 % 0x10000) 
0791 753B00     716            mov y+2, #low (2 / 0x10000) 
0794 753C00     716            mov y+3, #high(2 / 0x10000) 
0797 120255     717       lcall div32
079A            718   
079A D8DA       719       djnz  r0, sqrt32_loop
079C            720   
079C            721   sqrt32_done:
079C D004       722       pop   ar4
079E D003       723       pop   ar3
07A0 D002       724       pop   ar2
07A2 D001       725       pop   ar1
07A4 D000       726       pop   ar0
07A6 D0D0       727       pop   psw
07A8 D0E0       728       pop   acc
07AA 22         729       ret
07AB            730            
07AB            731   en
